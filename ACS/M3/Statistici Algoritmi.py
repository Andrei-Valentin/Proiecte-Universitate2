# -*- coding: utf-8 -*-
"""Vasile Andrei-Valentin Statistici algoritmi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VmhfrFckk8T7xdssBN3dOmreD3MB0_JS
"""

import cv2
import statistics as st
from google.colab.patches import cv2_imshow
import numpy as np
from numpy import dot
from numpy import linalg as la
from numpy.linalg import norm
import matplotlib
from matplotlib import pyplot as plt
from collections import Counter
import time
import os
import random

#Crearea matricei de antrenare
OptiuneAntrenare = 3

if OptiuneAntrenare == 1:
  nrPozeAntrenare = 6 # de aici trebuie modificata matricea de antrenare
elif OptiuneAntrenare == 2:
  nrPozeAntrenare = 8
elif OptiuneAntrenare == 3:
  nrPozeAntrenare = 9
A = np.zeros([10304, 40 * nrPozeAntrenare])

index = 0
pathSursa="/content/drive/MyDrive/Proiecte"


for i in range(1, 41):
  pathPersoane = pathSursa +"/s" + str(i) + "/"
  for j in range(1, nrPozeAntrenare + 1):
    pathPozaAntrenare = pathPersoane + str(j) + '.pgm'
    # citim poza ca matrice 112 x 92:
    pozaAntrenare = np.array(cv2.imread(pathPozaAntrenare,0))
    # vectorizam poza:
    pozaVect = pozaAntrenare.reshape(10304,)
    A[:,index] = pozaVect
    index = index + 1



#Algoritmul NN

def AlgoritmulNN(A, pozaCautata, norma):
  distante = np.zeros(len(A[0]))

  if(norma == "L1"):
    for i in range(0,len(distante)):
      distante[i] = np.linalg.norm((A[:,i]-pozaCautata), ord=1)

  elif(norma == "L2"):
    for i in range(0,len(distante)):
      distante[i] = la.norm(A[:,i]-pozaCautata)

  elif(norma == "LINF"):
    for i in range(0,len(distante)):
      distante[i] = np.linalg.norm((A[:,i]-pozaCautata), ord=np.inf)

  elif(norma == "LCOS"):
    for i in range(0,len(distante)):
      distante[i] = 1 - np.inner(A[:,i], pozaCautata)/(norm(A[:,i])*norm(pozaCautata))

  else:
    print("Nume norma incorect. Incercati L1, L2, LINF sau LCOS")
    return -1
    

  pozitia = np.argmin(distante) # returneaza indicele la care se afla cea mai mica distanta
  
  return pozitia # pozitia la care se afla imaginea gasita



#Algoritmul kNN

def AlgoritmulkNN(A, pozaCautata, norma, k):
  distante = np.zeros(len(A[0]))

  if(norma == "L1"):
    for i in range(0,len(distante)):
      distante[i] = np.linalg.norm((A[:,i]-pozaCautata), ord=1)

  elif(norma == "L2"):
    for i in range(0,len(distante)):
      distante[i] = la.norm(A[:,i]-pozaCautata)

  elif(norma == "LINF"):
    for i in range(0,len(distante)):
      distante[i] = np.linalg.norm((A[:,i]-pozaCautata), ord=np.inf)

  elif(norma == "LCOS"):
    for i in range(0,len(distante)):
      distante[i] = 1 - np.inner(A[:,i], pozaCautata)/(norm(A[:,i])*norm(pozaCautata))

  else:
    print("Nume norma incorect. Incercati L1, L2, LINF sau LCOS")
    return -1


  vector_pozitii = np.argsort(distante) # returneaza indicii la care se afla distantele cele mai mici (care au fost ordonate crescator)
  vector_pozitii = vector_pozitii[:k]

  print("Pozitiile imaginilor cu distantele cele mai mici:")
  print(vector_pozitii)
  print("Persoana din pozele respective:")
  print(vector_pozitii//nrPozeAntrenare+1)
  print()

  aparitii_clase = Counter(vector_pozitii//nrPozeAntrenare)
  predictie_knn = aparitii_clase.most_common(1)[0][0]*nrPozeAntrenare
  
  return predictie_knn # pozitia la care se afla prima imagine a persoanei gasite


def Eigenfaces(A, pozaCautata, norma, k):
  ###Preprocesare
  global timp_preproc
  global timp_cautare

  timp_start = time.perf_counter()

  media = np.mean(A, axis = 1) 

  A = (A.T - media).T

  L = np.dot(A.T, A)

  d, v = np.linalg.eig(L)

  v = np.dot(A, v)


  indici = np.argsort(d) 

  top_k_indici = indici[::-1][:k]

  HQPB = v[:,top_k_indici]


  proiectii = np.dot(A.T, HQPB)

  timp_fin = time.perf_counter()
  timp_preproc = timp_fin - timp_start # timpul scurs (durata preprocesarii)

  ###Interogare/Cautare
  timp_start = time.perf_counter()

  pozaCautata = pozaCautata - media

  pr_pozaCautata = np.dot(pozaCautata, HQPB)

  rezultat_EIG = AlgoritmulNN(proiectii.T, pr_pozaCautata , norma)

  timp_fin = time.perf_counter()
  timp_cautare = timp_fin - timp_start # timpul scurs (durata cautarii)

  return rezultat_EIG




def EigenfacesClase(A, pozaCautata, norma, k):
  ###Preprocesare
  global timp_preproc
  global timp_cautare

  timp_start = time.perf_counter()

  media = np.mean(A, axis = 1) 

  #Crearea tabloului RC
  RC = np.zeros([10304,40])

  for i in range(0,40):
    poze_persoana = np.zeros([10304, nrPozeAntrenare])
    for j in range(0,nrPozeAntrenare):
      poze_persoana[:,j] = A[:, i*nrPozeAntrenare + j]
    RC[:,i] = A[:, i*nrPozeAntrenare + random.randint(1, nrPozeAntrenare-1)]

  RC = (RC.T - media).T

  L = np.dot(RC.T, RC)

  d, v = np.linalg.eig(L)
  v = np.dot(RC, v)


  indici = np.argsort(d) 

  top_k_indici = indici[::-1][:k]

  HQPB = v[:,top_k_indici]

  proiectii = np.dot(RC.T, HQPB)

  timp_fin = time.perf_counter()
  timp_preproc = timp_fin - timp_start # timpul scurs (durata preprocesarii)

  ###Interogare/Cautare
  timp_start = time.perf_counter()

  pozaCautata = pozaCautata - media

  pr_pozaCautata = np.dot(pozaCautata, HQPB)

  rezultat_EIGC = AlgoritmulNN(proiectii.T, pr_pozaCautata , norma)

  timp_fin = time.perf_counter()
  timp_cautare = timp_fin - timp_start # timpul scurs (durata cautarii)

  return rezultat_EIGC


def Lanczos(A, pozaCautata, norma, k):
  global timp_preproc
  global timp_cautare

  #Preprocesare
  timp_start = time.perf_counter()

  media = np.mean(A, axis = 1)
  m = 10304
  q = np.zeros([m, k+2])
  q[:,0]=np.zeros(m)
  q[:,1]=np.ones(m)
  q[:,1]=q[:,1]/la.norm(q[:,1])

  for i in range(1,k+1):
    w = np.dot(A, np.dot(A.T, q[:,i])) - np.dot(la.norm(q[:,i-1]),q[:,i-1])
    a = np.dot(w, q[:,i])
    w = w - np.dot(a,q[:,i])
    q[:,i+1]=w/la.norm(q[:,i])

  HQPB = q[:,2:]

  timp_fin = time.perf_counter()
  timp_preproc = timp_fin - timp_start # timpul scurs (durata preprocesarii)


  #Cautare 
  timp_start = time.perf_counter()

  proiectii = np.dot(A.T, HQPB)

  pozaCautata = pozaCautata - media

  pr_pozaCautata = np.dot(pozaCautata, HQPB)

  rezultat_Lanczos = AlgoritmulNN(proiectii.T, pr_pozaCautata , norma)

  timp_fin = time.perf_counter()
  timp_cautare = timp_fin - timp_start # timpul scurs (durata cautarii)
  return rezultat_Lanczos


Algoritm = "EIGC"
Dataset = "ORL"

OptiuniK1 = [3, 5, 7, 9]
OptiuniK2 = [20, 40, 60, 80, 100]
OptiuniNorma = ["L1", "L2", "LINF", "LCOS"]
nrTotalTeste = 40 * (10 - nrPozeAntrenare)
numefisierRR = Dataset + '_' + str(nrPozeAntrenare) + '_' + Algoritm + '_' + 'RR.txt'
numefisierTMI = Dataset + '_' + str(nrPozeAntrenare) + '_' + Algoritm + '_' + 'TMI.txt'
numefisierTMP = Dataset + '_' + str(nrPozeAntrenare) + '_' + Algoritm + '_' + 'TMP.txt'

if Algoritm == "kNN":
  OptiuniK = OptiuniK1
elif Algoritm == "NN":
  OptiuniK = [0]
elif Algoritm == "EIG" or Algoritm == "EIGC" or Algoritm == "Lanczos":
  OptiuniK = OptiuniK2


exista = (os.path.exists(numefisierRR) and os.path.exists(numefisierTMI))
if exista:
  #daca au fost calculate deja statisticile afisam continutul fisierelor
  with open(numefisierRR) as fisier:
    print("Rata de recunoastere")
    print(fisier.read())
    print()

  if Algoritm == "EIG" or Algoritm == "EIGC" or Algoritm == "Lanczos": 
    with open(numefisierTMP) as fisier:
      print("Timpul mediu de preprocesare")
      print(fisier.read())
      print()

  with open(numefisierTMI) as fisier:
    print("Timpul mediu de interogare")
    print(fisier.read())
    print()
else:
  #deschidem fisiere pentru a scrie
  with open(numefisierRR, 'w') as f:
    f.write("k           L1           L2        LINF        LCOS \n")
  with open(numefisierTMI, 'w') as f:
    f.write("k           L1           L2        LINF        LCOS \n")

  #doar pentru algoritmii cu preprocesare
  if Algoritm == "EIG" or Algoritm == "EIGC" or Algoritm == "Lanczos": 
    with open(numefisierTMP, 'w') as f:
      f.write("k           L1           L2        LINF        LCOS \n")

#Pentru fiecare valoare k vom calcula timpii medii pentru fiecare norma in parte
  for k in OptiuniK:
    with open(numefisierRR, 'a') as f:
        f.write(str(k))
        #pentru alinierea textului
        if(k < 100):
          f.write('       ')
        else:
          f.write('      ')

    #doar pentru algoritmii cu preprocesare
    if Algoritm == "EIG" or Algoritm == "EIGC" or Algoritm == "Lanczos":
      with open(numefisierTMP, 'a') as f:
        f.write(str(k))
        if(k < 100):
          f.write('       ')
        else:
          f.write('      ')  

    with open(numefisierTMI, 'a') as f:
        f.write(str(k))
        if(k < 100):
          f.write('       ')
        else:
          f.write('      ')

    for norma in OptiuniNorma:
      nrRecunoasteriCorecte = 0
      timpiPreproc = []
      timpiInterogare = [] 

      for i in range(1,41): # ne mutam in directorul persoanei i
        for j in range(nrPozeAntrenare+1,11):
          pozaTest = (np.array(cv2.imread('/content/drive/MyDrive/Proiecte/s' + str(i) + '/' + str(j) + '.pgm',0))).reshape(10304,)


          timp_start = time.perf_counter() # start timer

          if(Algoritm == "NN"):
            predictie = AlgoritmulNN(A, pozaTest , norma)
          elif(Algoritm == "kNN"):
            predictie = AlgoritmulkNN(A, pozaTest , norma, k)
          elif(Algoritm == "EIG"):
            predictie = Eigenfaces(A, pozaTest , norma, k)
          elif(Algoritm == "EIGC"):
            predictie = EigenfacesClase(A, pozaTest , norma, k)
          elif(Algoritm == "Lanczos"):
            predictie = Lanczos(A, pozaTest , norma, k)

          timp_fin = time.perf_counter() # stop timer
          timp = timp_fin - timp_start # timpul masurat

          
          if Algoritm == "NN" or Algoritm == "kNN":
            timpiInterogare.append(timp)
          else: #doar pentru algoritmii cu preprocesare
            timpiInterogare.append(timp_cautare)
            timpiPreproc.append(timp_preproc)

          if (predictie//nrPozeAntrenare+1 == i): # verificam daca predictia a fost corecta
            nrRecunoasteriCorecte = nrRecunoasteriCorecte + 1

      rr = nrRecunoasteriCorecte / nrTotalTeste # calculam rata de recunoastere

      with open(numefisierRR, 'a') as f:
          f.write(str(format(rr, '.4f'))) 
          f.write('      ')

      tmi = st.mean(timpiInterogare)

      if Algoritm == "EIG" or Algoritm == "EIGC" or Algoritm == "Lanczos": # scriem timpul de preprocesare in fisier
        tmPreproc = st.mean(timpiPreproc) 
        with open(numefisierTMP, 'a') as f:
          f.write(str(format(tmPreproc, '.4f'))) 
          f.write('      ') 

      with open(numefisierTMI, 'a') as f: # scriem timpul de cautare in fisier
          f.write(str(format(tmi, '.4f'))) 
          f.write('      ')

      

    with open(numefisierRR, 'a') as f:
      f.write('\n')  

    if Algoritm == "EIG" or Algoritm == "EIGC" or Algoritm == "Lanczos":
      with open(numefisierTMP, 'a') as f:
        f.write('\n') 
    
    with open(numefisierTMI, 'a') as f:
      f.write('\n')
